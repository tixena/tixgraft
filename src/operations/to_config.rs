//! Convert CLI arguments to YAML configuration

use std::path::Path;

use crate::cli::Args;
use crate::config::Config;
use crate::operations::pull::{build_config_from_args, build_merged_config};
use crate::system::System;
use anyhow::Result;

/// Convert arguments to YAML configuration
///
/// # Errors
///
/// Returns an error if:
/// - The configuration file cannot be loaded or parsed
/// - The configuration is invalid
/// - The configuration cannot be serialized to YAML
#[inline]
pub fn generate_yaml_config(args: &Args, system: &dyn System) -> Result<String> {
    // Build the config structure
    let config = if Path::new(&args.config).exists() {
        // Load and merge with CLI overrides
        build_merged_config(args, system)?
    } else if !args.pulls.sources.is_empty() {
        // Build from CLI args only
        build_config_from_args(args)?
    } else {
        return Err(anyhow::anyhow!(
            "No configuration source provided. Specify --config or provide pull arguments."
        ));
    };

    // Validate the config
    config.validate(system)?;

    // Serialize to YAML with clean formatting
    serialize_config(&config)
}

/// Serialize Config to YAML string with proper formatting
fn serialize_config(config: &Config) -> Result<String> {
    // Use serde_yaml with custom formatting
    let yaml = serde_yaml::to_string(config)
        .map_err(|e| anyhow::anyhow!("Failed to serialize config to YAML: {e}"))?;

    // Post-process for better formatting
    let formatted = format_yaml_output(&yaml);

    Ok(formatted)
}

/// Format YAML output for readability
fn format_yaml_output(yaml: &str) -> String {
    // Add helpful comment at top
    let mut output = String::from("# Generated by tixgraft --to-config\n");
    output.push_str("# https://github.com/tixena/tixgraft\n\n");

    // Add the YAML content
    output.push_str(yaml);

    // Ensure trailing newline
    if !output.ends_with('\n') {
        output.push('\n');
    }

    output
}

#[cfg(test)]
#[expect(clippy::unwrap_used, reason = "These are unit tests")]
mod tests {
    use std::collections::HashMap;

    use super::*;
    use crate::cli::{PullConfig, ReplacementConfig};

    #[test]
    fn serialize_basic_config() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: Some("main".to_owned()),
            pulls: vec![PullConfig {
                source: "src".to_owned(),
                target: "dst".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec![],
                replacements: vec![],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        // Verify it contains expected fields
        assert!(yaml.contains("repository: my_organization/repo"));
        assert!(yaml.contains("tag: main"));
        assert!(yaml.contains("source: src"));
        assert!(yaml.contains("target: dst"));
    }

    #[test]
    fn serialize_with_header() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "src".to_owned(),
                target: "dst".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec![],
                replacements: vec![],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        // Verify header comment
        assert!(yaml.starts_with("# Generated by tixgraft --to-config"));
        assert!(yaml.contains("# https://github.com/tixena/tixgraft"));
    }

    #[test]
    fn roundtrip_basic() {
        let original_config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "src".to_owned(),
                target: "dst".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: true,
                commands: vec![],
                replacements: vec![],
                context: HashMap::new(),
            }],
        };

        // Serialize to YAML
        let yaml = serialize_config(&original_config).unwrap();

        // Parse back (skip comment lines)
        let yaml_without_comments: String = yaml
            .lines()
            .filter(|line| !line.starts_with('#'))
            .collect::<Vec<&str>>()
            .join("\n");

        let parsed_config: Config = serde_yaml::from_str(&yaml_without_comments).unwrap();

        // Should be equal
        assert_eq!(original_config.repository, parsed_config.repository);
        assert_eq!(original_config.tag, parsed_config.tag);
        assert_eq!(original_config.pulls.len(), parsed_config.pulls.len());
        assert_eq!(
            original_config.pulls[0].source,
            parsed_config.pulls[0].source
        );
        assert_eq!(original_config.pulls[0].reset, parsed_config.pulls[0].reset);
    }

    #[test]
    fn config_with_replacements() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "src".to_owned(),
                target: "dst".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec![],
                replacements: vec![
                    ReplacementConfig {
                        source: "{{VAR1}}".to_owned(),
                        target: Some("value1".to_owned()),
                        value_from_env: None,
                    },
                    ReplacementConfig {
                        source: "{{VAR2}}".to_owned(),
                        target: None,
                        value_from_env: Some("MY_ENV".to_owned()),
                    },
                ],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        assert!(yaml.contains("replacements:"));
        assert!(yaml.contains("source: '{{VAR1}}'") || yaml.contains("source: \"{{VAR1}}\""));
        assert!(yaml.contains("target: value1"));
        assert!(yaml.contains("valueFromEnv: MY_ENV"));
    }

    #[test]
    fn config_with_commands() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "src".to_owned(),
                target: "dst".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec!["npm install".to_owned(), "npm run build".to_owned()],
                replacements: vec![],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        assert!(yaml.contains("commands:"));
        assert!(yaml.contains("- npm install"));
        assert!(yaml.contains("- npm run build"));
    }

    #[test]
    fn config_per_pull_overrides() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("global/repo".to_owned()),
            tag: Some("v1".to_owned()),
            pulls: vec![
                PullConfig {
                    source: "src1".to_owned(),
                    target: "dst1".to_owned(),
                    pull_type: "directory".to_owned(),
                    repository: None, // Uses global
                    tag: None,        // Uses global
                    reset: false,
                    commands: vec![],
                    replacements: vec![],
                    context: HashMap::new(),
                },
                PullConfig {
                    source: "src2".to_owned(),
                    target: "dst2".to_owned(),
                    pull_type: "directory".to_owned(),
                    repository: Some("per-pull/repo".to_owned()), // Override
                    tag: Some("v2".to_owned()),                   // Override
                    reset: false,
                    commands: vec![],
                    replacements: vec![],
                    context: HashMap::new(),
                },
            ],
        };

        let yaml = serialize_config(&config).unwrap();

        // Second pull should have overrides
        assert!(yaml.contains("repository: per-pull/repo"));
        assert!(yaml.contains("tag: v2"));
    }

    #[test]
    fn config_with_file_type() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "file.txt".to_owned(),
                target: "output.txt".to_owned(),
                pull_type: "file".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec![],
                replacements: vec![],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        assert!(yaml.contains("type: file"));
    }

    #[test]
    fn config_with_special_characters_in_paths() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "path with spaces".to_owned(),
                target: "./target with spaces".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec![],
                replacements: vec![],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        // YAML should handle spaces properly (likely with quotes)
        assert!(yaml.contains("path with spaces"));
        assert!(yaml.contains("target with spaces"));
    }

    #[test]
    fn config_with_multiline_command() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "src".to_owned(),
                target: "dst".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec!["echo 'line1'\necho 'line2'".to_owned()],
                replacements: vec![],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        // YAML should preserve the newline in the command
        assert!(yaml.contains("commands:"));
    }

    #[test]
    fn config_empty_pulls_array_fails() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: Some("main".to_owned()),
            pulls: vec![],
        };

        // Serialization should work, but validation would fail
        let yaml = serialize_config(&config);
        yaml.unwrap();
    }

    #[test]
    fn replacement_with_special_chars() {
        let config = Config {
            context: HashMap::new(),

            repository: Some("my_organization/repo".to_owned()),
            tag: None,
            pulls: vec![PullConfig {
                source: "src".to_owned(),
                target: "dst".to_owned(),
                pull_type: "directory".to_owned(),
                repository: None,
                tag: None,
                reset: false,
                commands: vec![],
                replacements: vec![ReplacementConfig {
                    source: "{{VAR}}".to_owned(),
                    target: Some("value with $special &chars".to_owned()),
                    value_from_env: None,
                }],
                context: HashMap::new(),
            }],
        };

        let yaml = serialize_config(&config).unwrap();

        // YAML should properly escape/quote special characters
        assert!(yaml.contains("replacements:"));
        assert!(yaml.contains("VAR"));
    }
}
